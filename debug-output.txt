Godot Engine v4.4.1.stable.official.49a5bc7b6 - https://godotengine.org
Vulkan 1.4.311 - Forward+ - Using Device #1: AMD - AMD Radeon RX 560 Series (RADV POLARIS11)

--Main Shader--
    1 | shader_type spatial;
    2 | render_mode blend_mix, depth_draw_opaque, cull_disabled, diffuse_burley, specular_schlick_ggx;
    3 | 
    4 | 
    5 | uniform sampler2D atlas_texture : source_color, filter_nearest;
    6 | uniform vec2 atlas_dimensions = vec2(1.0, 1.0);
    7 | uniform vec2 frame_size = vec2(1.0, 1.0);
    8 | uniform int direction_count : hint_range(1, 8) = 3;
    9 | uniform int current_frame : hint_range(0, 15) = 0;
   10 | 
   11 | 
   12 | uniform vec3 target_position = vec3(0.0, 0.0, 0.0);
   13 | uniform bool auto_direction = true;
   14 | 
   15 | 
   16 | uniform float alpha_cut : hint_range(0.0, 1.0) = 0.5;
   17 | uniform vec4 albedo_color : source_color = vec4(1.0, 1.0, 1.0, 1.0);
   18 | uniform bool billboard_enabled = true;
   19 | 
   20 | varying vec3 world_position;
   21 | varying vec3 world_normal;
   22 | varying float calculated_direction;
   23 | varying float calculated_flip;
   24 | 
   25 | void vertex() {
   26 |  if (billboard_enabled) {
   27 |  
   28 |  vec3 model_scale = vec3(
   29 |  length(MODEL_MATRIX[0].xyz),
   30 |  length(MODEL_MATRIX[1].xyz),
   31 |  length(MODEL_MATRIX[2].xyz)
   32 |  );
   33 |  vec3 model_pos = MODEL_MATRIX[3].xyz;
   34 | 
   35 |  
   36 |  vec3 camera_pos = INV_VIEW_MATRIX[3].xyz;
   37 | 
   38 |  
   39 |  vec3 look_at = normalize(camera_pos - model_pos);
   40 |  look_at.y = 0.0; 
   41 | 
   42 |  
   43 |  if (length(look_at) < 0.001) {
   44 |  look_at = vec3(0.0, 0.0, 1.0);
   45 |  } else {
   46 |  look_at = normalize(look_at);
   47 |  }
   48 | 
   49 |  
   50 |  vec3 up = vec3(0.0, 1.0, 0.0);
   51 |  vec3 right = normalize(cross(up, look_at));
   52 |  vec3 forward = cross(right, up);
   53 | 
   54 |  
   55 |  mat4 billboard_model = mat4(
   56 |  vec4(right * model_scale.x, 0.0),
   57 |  vec4(up * model_scale.y, 0.0),
   58 |  vec4(forward * model_scale.z, 0.0),
   59 |  vec4(model_pos, 1.0)
   60 |  );
   61 | 
   62 |  
   63 |  vec4 world_vertex = billboard_model * vec4(VERTEX, 1.0);
   64 |  world_position = world_vertex.xyz;
   65 |  world_normal = forward;
   66 | 
   67 |  
   68 |  VERTEX = VERTEX; 
   69 |  MODELVIEW_MATRIX = VIEW_MATRIX * billboard_model;
   70 |  } else {
   71 |  
   72 |  world_position = (MODEL_MATRIX * vec4(VERTEX, 1.0)).xyz;
   73 |  world_normal = normalize((MODEL_MATRIX * vec4(NORMAL, 0.0)).xyz);
   74 |  }
   75 | 
   76 |  
   77 |  if (auto_direction) {
   78 |  
   79 |  vec3 camera_pos = INV_VIEW_MATRIX[3].xyz;
   80 | 
   81 |  
   82 |  vec3 to_camera = normalize(camera_pos - target_position);
   83 | 
   84 |  
   85 |  vec3 target_forward = normalize(MODEL_MATRIX[2].xyz);
   86 |  vec3 target_right = normalize(MODEL_MATRIX[0].xyz);
   87 | 
   88 |  
   89 |  float forward_dot = dot(target_forward, to_camera);
   90 |  float right_dot = dot(target_right, to_camera);
   91 | 
   92 |  
   93 |  if (forward_dot < -0.5) {
   94 |  calculated_direction = 0.0; 
   95 |  } else if (forward_dot > 0.5) {
   96 |  calculated_direction = 2.0; 
   97 |  } else {
   98 |  calculated_direction = 1.0; 
   99 |  }
  100 | 
  101 |  
  102 |  calculated_flip = (calculated_direction == 1.0 && right_dot > 0.0) ? 1.0 : 0.0;
  103 |  } else {
  104 |  
E 105->  calculated_direction = float(current_direction);
  106 |  calculated_flip = flip_horizontal ? 1.0 : 0.0;
  107 |  }
  108 | }
  109 | 
  110 | void fragment() {
  111 |  
  112 |  vec2 atlas_uv = UV;
  113 | 
  114 |  
  115 |  int direction_index = int(calculated_direction);
  116 | 
  117 |  
  118 |  vec2 frame_pos = vec2(
  119 |  float(current_frame) * frame_size.x,
  120 |  float(direction_index) * frame_size.y
  121 |  );
  122 | 
  123 |  
  124 |  vec2 normalized_frame_pos = frame_pos / atlas_dimensions;
  125 |  vec2 normalized_frame_size = frame_size / atlas_dimensions;
  126 | 
  127 |  
  128 |  if (calculated_flip > 0.5) {
  129 |  atlas_uv.x = 1.0 - atlas_uv.x;
  130 |  }
  131 | 
  132 |  
  133 |  vec2 final_uv = normalized_frame_pos + (atlas_uv * normalized_frame_size);
  134 | 
  135 |  
  136 |  vec4 tex_color = texture(atlas_texture, final_uv);
  137 | 
  138 |  
  139 |  ALBEDO = tex_color.rgb * albedo_color.rgb;
  140 |  ALPHA = tex_color.a * albedo_color.a;
  141 | 
  142 |  
  143 |  if (ALPHA < alpha_cut) {
  144 |  discard;
  145 |  }
  146 | }
  147 | 
--- Debugging process stopped ---
